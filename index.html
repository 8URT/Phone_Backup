<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Media Backup to SSD</title>
    <style>
        /* CSS Custom Properties (Variables) for a maintainable design system */
        :root {
            /* Colors */
            --primary-color: #667eea;
            --secondary-color: #764ba2;
            --tertiary-color: #38b2ac;
            --danger-color: #e53e3e;
            --success-color: #38a169;
            --warning-color: #ed8936;
            --info-color: #3182ce;
            --text-dark: #2d3748;
            --text-light: #4a5568;
            --bg-light: #fff;
            --bg-container: rgba(255, 255, 255, 0.95);

            /* Gradients */
            --primary-gradient: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
            --secondary-gradient: linear-gradient(135deg, var(--tertiary-color) 0%, #319795 100%);
            --danger-gradient: linear-gradient(135deg, var(--danger-color) 0%, #c53030 100%);
            --info-gradient: linear-gradient(135deg, var(--info-color) 0%, #2a699c 100%);

            /* Spacing */
            --space-xs: 5px;
            --space-sm: 10px;
            --space-md: 15px;
            --space-lg: 30px;

            /* Border Radius */
            --radius-sm: 8px;
            --radius-md: 15px;
            --radius-lg: 20px;

            /* Shadows */
            --shadow-sm: 0 4px 6px rgba(0, 0, 0, 0.1);
            --shadow-md: 0 10px 20px rgba(0, 0, 0, 0.1);
        }

        /* General styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--primary-gradient);
            min-height: 100vh;
            padding: var(--space-lg);
            color: var(--text-light);
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background: var(--bg-container);
            backdrop-filter: blur(20px);
            border-radius: var(--radius-lg);
            padding: var(--space-lg);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }

        h1 {
            text-align: center;
            color: var(--text-dark);
            margin-bottom: var(--space-lg);
            font-size: 2.5rem;
            font-weight: 300;
        }

        .section {
            margin-bottom: var(--space-lg);
            padding: 20px;
            background: rgba(255, 255, 255, 0.7);
            border-radius: var(--radius-md);
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow: var(--shadow-sm);
        }

        .section h2 {
            color: var(--text-dark);
            margin-bottom: var(--space-md);
            font-size: 1.3rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        /* Button styles */
        .btn {
            background: var(--primary-gradient);
            color: var(--bg-light);
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 500;
            transition: all 0.3s ease;
            margin: var(--space-xs);
            display: inline-flex;
            align-items: center;
            gap: 8px;
            white-space: nowrap;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn.secondary {
            background: var(--secondary-gradient);
        }

        .btn.danger {
            background: var(--danger-gradient);
        }

        .btn.loading {
            cursor: wait;
            opacity: 0.8;
        }

        .spinner {
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top: 2px solid white;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Progress and Status styles */
        .progress-container {
            margin-top: var(--space-md);
            display: none;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e2e8f0;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: var(--space-sm);
        }

        .progress-fill {
            height: 100%;
            background: var(--primary-gradient);
            width: 0%;
            transition: width 0.3s ease;
        }

        .status {
            padding: var(--space-md);
            border-radius: var(--radius-sm);
            margin-top: var(--space-md);
            font-weight: 500;
        }

        .status.success {
            background: #c6f6d5;
            color: #22543d;
            border-left: 4px solid var(--success-color);
        }

        .status.error {
            background: #fed7d7;
            color: #742a2a;
            border-left: 4px solid var(--danger-color);
        }

        .status.info {
            background: #bee3f8;
            color: #2a4365;
            border-left: 4px solid var(--info-color);
        }

        .status.warning {
            background: #fef5e7;
            color: #744210;
            border-left: 4px solid var(--warning-color);
        }

        /* File list and stats styles */
        .file-info {
            background: rgba(255, 255, 255, 0.8);
            padding: var(--space-sm);
            border-radius: var(--radius-sm);
            margin: var(--space-xs) 0;
            border-left: 3px solid var(--primary-color);
            font-size: 0.9rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .file-info.backed-up {
            border-left-color: var(--success-color);
            background: rgba(200, 246, 213, 0.3);
        }

        .file-info.new {
            border-left-color: var(--warning-color);
            background: rgba(254, 245, 231, 0.3);
        }

        .file-status {
            font-size: 0.8rem;
            padding: 2px 8px;
            border-radius: 12px;
            font-weight: bold;
        }

        .file-status.backed-up {
            background: #c6f6d5;
            color: #22543d;
        }

        .file-status.new {
            background: #fef5e7;
            color: #744210;
        }

        /* Icon styles */
        .icon {
            width: 20px;
            height: 20px;
            fill: currentColor;
        }

        input[type="file"] {
            display: none; /* Hide the native file input, which is triggered by a button */
        }

        /* Stats grid */
        .backup-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: var(--space-md);
            margin-top: var(--space-md);
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.8);
            padding: var(--space-md);
            border-radius: var(--radius-sm);
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .stat-number {
            font-size: 1.8rem;
            font-weight: bold;
            color: var(--primary-color);
        }

        .stat-label {
            color: var(--text-light);
            font-size: 0.85rem;
            margin-top: 5px;
        }

        /* Index info and toggle section */
        .index-info {
            background: rgba(255, 255, 255, 0.9);
            border-radius: var(--radius-sm);
            padding: var(--space-md);
            margin-top: var(--space-md);
            border: 1px solid rgba(102, 126, 234, 0.2);
        }

        .index-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-sm);
            flex-wrap: wrap; /* Allow wrapping on small screens */
            gap: var(--space-sm);
        }

        .index-details {
            font-size: 0.9rem;
            color: var(--text-light);
            line-height: 1.5;
        }

        .toggle-section {
            margin-top: var(--space-md);
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .toggle-section h3 {
            font-size: 1.1rem;
            font-weight: 500;
        }

        .toggle-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .toggle-content.open {
            max-height: 500px; /* A safe, large number to allow content to show */
        }

        /* Responsive adjustments */
        @media (max-width: 600px) {
            .container {
                padding: 20px;
                margin: 10px;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            .btn {
                padding: 10px 20px;
                font-size: 0.9rem;
            }

            .stat-number {
                font-size: 1.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üß†üíæ Smart Media Backup</h1>
        
        <div class="section">
            <h2>
                <svg class="icon" viewBox="0 0 24 24">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
                </svg>
                Backup Index Status
            </h2>
            <div id="indexStatus" class="index-info">
                <div class="index-header">
                    <strong>üìä Index Information</strong>
                    <div>
                        <button class="btn secondary" onclick="loadIndex()" aria-label="Refresh Index">
                            <svg class="icon" viewBox="0 0 24 24">
                                <path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 8 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/>
                            </svg>
                            Refresh
                        </button>
                        <button class="btn danger" onclick="clearIndex()" aria-label="Clear Backup Index">
                            <svg class="icon" viewBox="0 0 24 24">
                                <path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/>
                            </svg>
                            Clear
                        </button>
                    </div>
                </div>
                <div class="index-details" id="indexDetails">
                    No index found. Will create new index on first backup.
                </div>
            </div>
        </div>
        
        <div class="section">
            <h2>
                <svg class="icon" viewBox="0 0 24 24">
                    <path d="M9 16h6v-6h4l-7-7-7 7h4v6zm-4 2h14v2H5v-2z"/>
                </svg>
                Select Media Files
            </h2>
            <input type="file" id="fileInput" multiple accept="image/*,video/*">
            <button class="btn" onclick="selectFiles()">
                <svg class="icon" viewBox="0 0 24 24">
                    <path d="M9 16h6v-6h4l-7-7-7 7h4v6zm-4 2h14v2H5v-2z"/>
                </svg>
                Choose Files
            </button>
            <button class="btn" onclick="selectFolder()">
                <svg class="icon" viewBox="0 0 24 24">
                    <path d="M10 4H4c-1.11 0-2 .89-2 2v12c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2h-8l-2-2z"/>
                </svg>
                Select Folder
            </button>
        </div>

        <div class="section">
            <h2>
                <svg class="icon" viewBox="0 0 24 24">
                    <path d="M6 2c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V8l-6-6H6zm7 7V3.5L18.5 9H13z"/>
                </svg>
                Backup Destination
            </h2>
            <button class="btn" onclick="selectDestination()">
                <svg class="icon" viewBox="0 0 24 24">
                    <path d="M20 6h-2.18c.11-.31.18-.65.18-1a2.996 2.996 0 0 0-5.5-1.65l-.5.67-.5-.68C10.96 2.54 10 2 10 2H4c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2z"/>
                </svg>
                Choose SSD Location
            </button>
            <div id="destinationInfo" class="status info" style="display: none;"></div>
        </div>

        <div class="section">
            <h2>
                <svg class="icon" viewBox="0 0 24 24">
                    <path d="M19 3H5c-1.11 0-2 .9-2 2v14c0 1.11.89 2 2 2h14c1.11 0 2-.89 2-2V5c0-1.11-.89-2-2-2zm-5 14H7v-2h7v2zm3-4H7v-2h10v2zm0-4H7V7h10v2z"/>
                </svg>
                File Analysis
            </h2>
            <div class="backup-stats">
                <div class="stat-card">
                    <div class="stat-number" id="totalFiles">0</div>
                    <div class="stat-label">Total Files</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="newFiles">0</div>
                    <div class="stat-label">New Files</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="backedUpFiles">0</div>
                    <div class="stat-label">Already Backed</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="totalSize">0 MB</div>
                    <div class="stat-label">New Data Size</div>
                </div>
            </div>
            
            <div class="toggle-section" onclick="toggleFileList()">
                <h3 style="cursor: pointer; display: flex; align-items: center; gap: 10px;">
                    <svg class="icon" id="toggleIcon" viewBox="0 0 24 24">
                        <path d="M7 10l5 5 5-5z"/>
                    </svg>
                    File Details
                </h3>
            </div>
            <div class="toggle-content" id="fileListContainer">
                <div id="fileList"></div>
            </div>
        </div>

        <div class="section">
            <h2>
                <svg class="icon" viewBox="0 0 24 24">
                    <path d="M5 20h14v-2H5v2zM19 9h-4V3H9v6H5l7 7 7-7z"/>
                </svg>
                Smart Backup
            </h2>
            <button class="btn" id="backupBtn" onclick="startBackup()" disabled>
                <svg class="icon" viewBox="0 0 24 24">
                    <path d="M5 20h14v-2H5v2zM19 9h-4V3H9v6H5l7 7 7-7z"/>
                </svg>
                Backup New Files Only
            </button>
            
            <div class="progress-container" id="progressContainer">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div id="progressText">Preparing backup...</div>
            </div>
        </div>

        <div id="statusContainer"></div>
    </div>

    <script>
        // State management
        const appState = {
            selectedFiles: [],
            destinationHandle: null,
            backupIndex: {},
            analysisResults: {
                newFiles: [],
                backedUpFiles: [],
                totalNewSize: 0,
            },
        };

        // UI Element references for easier access
        const fileListElement = document.getElementById('fileList');
        const totalFilesElement = document.getElementById('totalFiles');
        const newFilesElement = document.getElementById('newFiles');
        const backedUpFilesElement = document.getElementById('backedUpFiles');
        const totalSizeElement = document.getElementById('totalSize');
        const backupBtnElement = document.getElementById('backupBtn');
        const progressContainerElement = document.getElementById('progressContainer');
        const progressFillElement = document.getElementById('progressFill');
        const progressTextElement = document.getElementById('progressText');
        const statusContainerElement = document.getElementById('statusContainer');
        const indexDetailsElement = document.getElementById('indexDetails');
        const destinationInfoElement = document.getElementById('destinationInfo');
        const fileInput = document.getElementById('fileInput');

        // Helper function for file size formatting
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
        }

        // Generate file hash (using SHA-256 for integrity check)
        async function generateFileHash(file) {
            const buffer = await file.arrayBuffer();
            const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
        }

        // Show a temporary status message
        function showStatus(message, type) {
            const status = document.createElement('div');
            status.className = `status ${type}`;
            status.textContent = message;
            
            statusContainerElement.appendChild(status);
            
            setTimeout(() => {
                if (status.parentNode) {
                    status.parentNode.removeChild(status);
                }
            }, 5000);
        }

        // Load existing backup index from destination
        async function loadIndex() {
            try {
                if (!appState.destinationHandle) {
                    showStatus('Please select a backup destination first.', 'warning');
                    return;
                }

                const indexFile = await appState.destinationHandle.getFileHandle('backup_index.json', { create: false });
                const file = await indexFile.getFile();
                const text = await file.text();
                appState.backupIndex = JSON.parse(text);
                
                showStatus('‚úÖ Backup index loaded successfully.', 'success');
                
            } catch (error) {
                if (error.name === 'NotFoundError') {
                    appState.backupIndex = {
                        created: new Date().toISOString(),
                        lastUpdated: new Date().toISOString(),
                        totalBackups: 0,
                        files: {}
                    };
                    showStatus('üìù No existing index found. A new one will be created.', 'info');
                } else {
                    console.error('Error loading index:', error);
                    showStatus(`Error loading index: ${error.message}`, 'error');
                }
            } finally {
                updateIndexDisplay();
                if (appState.selectedFiles.length > 0) {
                    await analyzeFiles();
                }
            }
        }

        // Save backup index to destination
        async function saveIndex() {
            try {
                if (!appState.destinationHandle) return;

                appState.backupIndex.lastUpdated = new Date().toISOString();
                const indexFile = await appState.destinationHandle.getFileHandle('backup_index.json', { create: true });
                const writable = await indexFile.createWritable();
                await writable.write(JSON.stringify(appState.backupIndex, null, 2));
                await writable.close();
            } catch (error) {
                console.error('Error saving index:', error);
                showStatus('Warning: Could not save index file. Backup history may be lost.', 'warning');
            }
        }

        // Clear backup index and reset state
        async function clearIndex() {
            if (confirm('Are you sure you want to clear the backup index? This will reset all backup history.')) {
                appState.backupIndex = {
                    created: new Date().toISOString(),
                    lastUpdated: new Date().toISOString(),
                    totalBackups: 0,
                    files: {}
                };
                await saveIndex();
                updateIndexDisplay();
                showStatus('üóëÔ∏è Backup index cleared.', 'info');
                
                if (appState.selectedFiles.length > 0) {
                    await analyzeFiles();
                }
            }
        }

        // Update the visual display of the backup index status
        function updateIndexDisplay() {
            const fileCount = Object.keys(appState.backupIndex.files || {}).length;
            
            if (fileCount === 0) {
                indexDetailsElement.innerHTML = `
                    <div>üìù <strong>New Index</strong></div>
                    <div>Created: ${new Date(appState.backupIndex.created).toLocaleString()}</div>
                    <div>No files backed up yet.</div>
                `;
            } else {
                indexDetailsElement.innerHTML = `
                    <div>üìä <strong>Index Statistics</strong></div>
                    <div>Created: ${new Date(appState.backupIndex.created).toLocaleDateString()}</div>
                    <div>Last Updated: ${new Date(appState.backupIndex.lastUpdated).toLocaleString()}</div>
                    <div>Total Backups: ${appState.backupIndex.totalBackups}</div>
                    <div>Files Tracked: ${fileCount}</div>
                `;
            }
        }

        // Analyze selected files against the backup index
        async function analyzeFiles() {
            showStatus('üîç Analyzing files against backup index...', 'info');
            backupBtnElement.disabled = true;
            backupBtnElement.classList.add('loading');
            backupBtnElement.innerHTML = '<span class="spinner"></span> Analyzing...';

            let newFiles = [];
            let backedUpFiles = [];
            let totalNewSize = 0;

            for (const file of appState.selectedFiles) {
                const fileKey = `${file.name}_${file.size}_${file.lastModified}`;
                const indexEntry = appState.backupIndex.files[fileKey];
                
                // Check if file exists in index and if hash matches (for change detection)
                if (indexEntry) {
                    const currentHash = await generateFileHash(file);
                    if (indexEntry.hash === currentHash) {
                        backedUpFiles.push(file);
                    } else {
                        // File exists but has changed, treat as new
                        newFiles.push(file);
                        totalNewSize += file.size;
                    }
                } else {
                    // New file, not in the index
                    newFiles.push(file);
                    totalNewSize += file.size;
                }
            }

            appState.analysisResults = {
                newFiles,
                backedUpFiles,
                totalNewSize
            };
            
            updateFileList();
            updateBackupButton();
            backupBtnElement.classList.remove('loading');
            showStatus(`‚úÖ Analysis complete: ${newFiles.length} new files, ${backedUpFiles.length} already backed up.`, 'success');
        }

        // Select files using the native file input
        async function selectFiles() {
            fileInput.click();
            fileInput.onchange = async (e) => {
                const files = Array.from(e.target.files);
                appState.selectedFiles = files.filter(file => 
                    file.type.startsWith('image/') || file.type.startsWith('video/')
                );
                
                if (appState.selectedFiles.length > 0) {
                    await analyzeFiles();
                } else {
                    updateFileList();
                    updateBackupButton();
                    showStatus('No media files selected.', 'info');
                }
            };
        }

        // Select a folder using the File System Access API
        async function selectFolder() {
            try {
                if (!('showDirectoryPicker' in window)) {
                    showStatus('Directory picker not supported. Please use file selection.', 'error');
                    return;
                }
                const dirHandle = await window.showDirectoryPicker();
                const files = [];
                
                showStatus('üìÇ Reading folder contents...', 'info');
                
                async function processDirectory(dirHandle) {
                    for await (const entry of dirHandle.values()) {
                        if (entry.kind === 'file' && (entry.name.endsWith('.jpg') || entry.name.endsWith('.png') || entry.name.endsWith('.mp4') || entry.name.endsWith('.mov'))) {
                            const file = await entry.getFile();
                            files.push(file);
                        } else if (entry.kind === 'directory') {
                            await processDirectory(entry);
                        }
                    }
                }
                
                await processDirectory(dirHandle);
                appState.selectedFiles = files;
                
                if (files.length > 0) {
                    await analyzeFiles();
                } else {
                    showStatus('No media files found in selected folder.', 'warning');
                    updateFileList();
                    updateBackupButton();
                }
            } catch (error) {
                console.error('Error selecting folder:', error);
                showStatus(`Error selecting folder: ${error.message}`, 'error');
            }
        }

        // Select backup destination
        async function selectDestination() {
            try {
                if (!('showDirectoryPicker' in window)) {
                    showStatus('Directory picker not supported on this browser.', 'error');
                    return;
                }
                appState.destinationHandle = await window.showDirectoryPicker({ mode: 'readwrite' });
                destinationInfoElement.textContent = `Backup destination: ${appState.destinationHandle.name}`;
                destinationInfoElement.style.display = 'block';
                
                await loadIndex();
            } catch (error) {
                console.error('Error selecting destination:', error);
                showStatus(`Error selecting destination: ${error.message}`, 'error');
            }
        }

        // Update the file list and stats display
        function updateFileList() {
            fileListElement.innerHTML = '';
            
            const { newFiles, backedUpFiles, totalNewSize } = appState.analysisResults;
            
            const renderFile = (file, isNew) => {
                const fileInfo = document.createElement('div');
                fileInfo.className = `file-info ${isNew ? 'new' : 'backed-up'}`;
                const sizeDisplay = formatFileSize(file.size);
                
                fileInfo.innerHTML = `
                    <div>
                        <strong>${file.name}</strong><br>
                        <small>Type: ${file.type} | Size: ${sizeDisplay}</small>
                    </div>
                    <span class="file-status ${isNew ? 'new' : 'backed-up'}">${isNew ? 'üì§ NEW' : '‚úì BACKED UP'}</span>
                `;
                fileListElement.appendChild(fileInfo);
            };

            backedUpFiles.forEach(file => renderFile(file, false));
            newFiles.forEach(file => renderFile(file, true));
            
            totalFilesElement.textContent = appState.selectedFiles.length;
            newFilesElement.textContent = newFiles.length;
            backedUpFilesElement.textContent = backedUpFiles.length;
            totalSizeElement.textContent = formatFileSize(totalNewSize);
        }

        // Toggle file list visibility
        function toggleFileList() {
            const container = document.getElementById('fileListContainer');
            const icon = document.getElementById('toggleIcon');
            
            if (container.classList.contains('open')) {
                container.classList.remove('open');
                icon.innerHTML = '<path d="M7 10l5 5 5-5z"/>';
            } else {
                container.classList.add('open');
                icon.innerHTML = '<path d="M7 14l5-5 5 5z"/>';
            }
        }

        // Update backup button state and text
        function updateBackupButton() {
            const { newFiles } = appState.analysisResults;
            
            backupBtnElement.disabled = newFiles.length === 0 || !appState.destinationHandle;
            
            if (newFiles.length === 0 && appState.selectedFiles.length > 0) {
                backupBtnElement.textContent = '‚úì All Files Already Backed Up';
            } else {
                backupBtnElement.innerHTML = `
                    <svg class="icon" viewBox="0 0 24 24">
                        <path d="M5 20h14v-2H5v2zM19 9h-4V3H9v6H5l7 7 7-7z"/>
                    </svg>
                    Backup ${newFiles.length} New Files
                `;
            }
        }

        // Start the smart backup process
        async function startBackup() {
            const { newFiles } = appState.analysisResults;
            
            if (newFiles.length === 0 || !appState.destinationHandle) {
                showStatus('No new files to backup.', 'info');
                return;
            }

            // UI feedback for backup process
            progressContainerElement.style.display = 'block';
            backupBtnElement.disabled = true;
            backupBtnElement.classList.add('loading');
            
            let completedFiles = 0;
            let errors = [];

            try {
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').split('T')[0];
                const backupFolderName = `MediaBackup_${timestamp}`;
                
                const backupFolder = await appState.destinationHandle.getDirectoryHandle(backupFolderName, { create: true });
                
                for (let i = 0; i < newFiles.length; i++) {
                    const file = newFiles[i];
                    progressTextElement.textContent = `Backing up: ${file.name} (${i + 1}/${newFiles.length})`;
                    
                    try {
                        const fileHash = await generateFileHash(file);
                        const fileHandle = await backupFolder.getFileHandle(file.name, { create: true });
                        const writable = await fileHandle.createWritable();
                        await writable.write(file);
                        await writable.close();
                        
                        const fileKey = `${file.name}_${file.size}_${file.lastModified}`;
                        appState.backupIndex.files[fileKey] = {
                            name: file.name,
                            size: file.size,
                            type: file.type,
                            lastModified: file.lastModified,
                            hash: fileHash,
                            backupDate: new Date().toISOString(),
                            backupLocation: `${backupFolderName}/${file.name}`
                        };
                        
                        completedFiles++;
                    } catch (error) {
                        console.error(`Error backing up ${file.name}:`, error);
                        errors.push(`${file.name}: ${error.message}`);
                    }
                    
                    const progress = ((i + 1) / newFiles.length) * 100;
                    progressFillElement.style.width = `${progress}%`;
                }
                
                appState.backupIndex.totalBackups++;
                await saveIndex();
                await analyzeFiles();
                
                if (errors.length === 0) {
                    showStatus(`‚úÖ Backup complete! ${completedFiles} new files backed up.`, 'success');
                } else {
                    showStatus(`‚ö†Ô∏è Backup completed with ${errors.length} errors. ${completedFiles} files backed up successfully.`, 'warning');
                }
                
                progressTextElement.textContent = 'Backup completed!';
            } catch (error) {
                console.error('Backup error:', error);
                showStatus(`Backup failed: ${error.message}`, 'error');
            } finally {
                backupBtnElement.disabled = false;
                backupBtnElement.classList.remove('loading');
                setTimeout(() => {
                    progressContainerElement.style.display = 'none';
                    progressFillElement.style.width = '0%';
                }, 3000);
            }
        }

        // Initialize the app on window load
        window.onload = function() {
            if (!('showDirectoryPicker' in window)) {
                showStatus('‚ö†Ô∏è This app requires a browser that supports the File System Access API, such as Chrome or Edge.', 'error');
            } else {
                showStatus('‚úÖ Smart backup system ready! Select files and a destination to begin.', 'success');
            }
            
            updateIndexDisplay();
            updateFileList();
            updateBackupButton();
        };
    </script>
</body>
</html>